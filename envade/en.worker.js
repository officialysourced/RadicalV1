(()=>{"use strict";let e=globalThis.fetch,t=globalThis.SharedWorker,r=globalThis.localStorage,a=globalThis.navigator.serviceWorker,s=MessagePort.prototype.postMessage,o={prototype:{send:WebSocket.prototype.send},CLOSED:WebSocket.CLOSED,CLOSING:WebSocket.CLOSING,CONNECTING:WebSocket.CONNECTING,OPEN:WebSocket.OPEN};async function n(){let e=Promise.race([Promise.any((await self.clients.matchAll({type:"window",includeUncontrolled:!0})).map(async e=>{let t,r=await (t=new MessageChannel,new Promise(r=>{e.postMessage({type:"getPort",port:t.port2},[t.port2]),t.port1.onmessage=e=>{r(e.data)}}));return await i(r),r})),new Promise((e,t)=>setTimeout(t,1e3,TypeError("timeout")))]);try{return await e}catch(e){if(e instanceof AggregateError)throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),Error("All clients returned an invalid MessagePort.");return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),await n()}}function i(e){let t=new MessageChannel,r=new Promise((e,r)=>{t.port1.onmessage=t=>{"pong"===t.data.type&&e()},setTimeout(r,1500)});return s.call(e,{message:{type:"ping"},port:t.port2},[t.port2]),r}function l(e,r){let o=new t(e,"bare-mux-worker");return r&&a.addEventListener("message",r=>{if("getPort"===r.data.type&&r.data.port){console.debug("bare-mux: recieved request for port from sw");let a=new t(e,"bare-mux-worker");s.call(r.data.port,a.port,[a.port])}}),o.port}class c{constructor(e){this.channel=new BroadcastChannel("bare-mux"),e instanceof MessagePort||e instanceof Promise?this.port=e:this.createChannel(e,!0)}createChannel(e,t){if(self.clients)this.port=n(),this.channel.onmessage=e=>{"refreshPort"===e.data.type&&(this.port=n())};else if(e&&SharedWorker){if(!e.startsWith("/")&&!e.includes("://"))throw Error("Invalid URL. Must be absolute or start at the root.");this.port=l(e,t),console.debug("bare-mux: setting localStorage bare-mux-path to",e),r["bare-mux-path"]=e}else{if(!SharedWorker)throw Error("Unable to get a channel to the SharedWorker.");{let e=r["bare-mux-path"];if(console.debug("bare-mux: got localStorage bare-mux-path:",e),!e)throw Error("Unable to get bare-mux workerPath from localStorage.");this.port=l(e,t)}}}async sendMessage(e,t){this.port instanceof Promise&&(this.port=await this.port);try{await i(this.port)}catch{return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),this.createChannel(),await this.sendMessage(e,t)}let r=new MessageChannel,a=[r.port2,...t||[]],o=new Promise((e,t)=>{r.port1.onmessage=r=>{let a=r.data;"error"===a.type?t(a.error):e(a)}});return s.call(this.port,{message:e,port:r.port2},a),await o}}class d extends EventTarget{constructor(e,t=[],r,a){super(),this.protocols=t,this.readyState=o.CONNECTING,this.url=e.toString(),this.protocols=t;let s=e=>{this.protocols=e,this.readyState=o.OPEN;let t=new Event("open");this.dispatchEvent(t)},n=async e=>{let t=new MessageEvent("message",{data:e});this.dispatchEvent(t)},i=(e,t)=>{this.readyState=o.CLOSED;let r=new CloseEvent("close",{code:e,reason:t});this.dispatchEvent(r)},l=()=>{this.readyState=o.CLOSED;let e=new Event("error");this.dispatchEvent(e)};this.channel=new MessageChannel,this.channel.port1.onmessage=e=>{"open"===e.data.type?s(e.data.args[0]):"message"===e.data.type?n(e.data.args[0]):"close"===e.data.type?i(e.data.args[0],e.data.args[1]):"error"===e.data.type&&l()},r.sendMessage({type:"websocket",websocket:{url:e.toString(),protocols:t,requestHeaders:a,channel:this.channel.port2}},[this.channel.port2])}send(...e){if(this.readyState===o.CONNECTING)throw new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");let t=e[0];t.buffer&&(t=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)),s.call(this.channel.port1,{type:"data",data:t},t instanceof ArrayBuffer?[t]:[])}close(e,t){s.call(this.channel.port1,{type:"close",closeCode:e,closeReason:t})}}let h=["ws:","wss:"],u=[101,204,205,304],p=[301,302,303,307,308];class w{constructor(e){this.worker=new c(e)}createWebSocket(e,t=[],r,a){try{e=new URL(e)}catch(t){throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${e}' is invalid.`)}if(!h.includes(e.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e.protocol}' is not allowed.`);for(let e of(Array.isArray(t)||(t=[t]),t=t.map(String)))if(!function(e){for(let t=0;t<e.length;t++){let r=e[t];if(!"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~".includes(r))return!1}return!0}(e))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${e}' is invalid.`);return a=a||{},new d(e,t,this.worker,a)}async fetch(t,r){let a=new Request(t,r),s=r?.headers||a.headers,o=s instanceof Headers?Object.fromEntries(s):s,n=a.body,i=new URL(a.url);if(i.protocol.startsWith("blob:")){let t=await e(i),r=new Response(t.body,t);return r.rawHeaders=Object.fromEntries(t.headers),r}for(let e=0;;e++){let t=(await this.worker.sendMessage({type:"fetch",fetch:{remote:i.toString(),method:a.method,headers:o,body:n||void 0}},n?[n]:[])).fetch,s=new Response(u.includes(t.status)?void 0:t.body,{headers:new Headers(t.headers),status:t.status,statusText:t.statusText});s.rawHeaders=t.headers,s.rawResponse=t,s.finalURL=i.toString();let l=r?.redirect||a.redirect;if(!p.includes(s.status))return s;switch(l){case"follow":{let t=s.headers.get("location");if(20>e&&null!==t){i=new URL(t,i);continue}throw TypeError("Failed to fetch")}case"error":throw TypeError("Failed to fetch");case"manual":return s}}}}console.debug("bare-mux: running v2.1.7 (build c56d286)"),self.EnvadeServiceWorker=class{client;constructor(){this.client=new w}shouldRoute({request:e}){return e.url.startsWith(location.origin+self.__envade$config.prefix)}async handleFetch({request:e}){let t=self.__envade$rewrite.url.unwriteUrl(e.url);try{if(console.log("Fetching URL:",t),t.startsWith("data:")||t.startsWith("blob:")){t.startsWith("blob:")&&(t=function(e){let t=new URL(e.substring(5));return`blob:${location.origin}${t.pathname}`}(t)),console.log("Handling data or blob URL:",t);let e=await fetch(t,{});return new Response(e.body,{status:e.status,statusText:e.statusText,headers:e.headers})}let r=new Headers(e.headers),a=new URL(t);r.set("host",a.host),r.set("origin",a.origin);let s=await this.client.fetch(t,{method:e.method,body:e.body,headers:r,credentials:"omit",mode:"cors"===e.mode?e.mode:"same-origin",cache:e.cache,redirect:e.redirect,duplex:"half"}),o=await self.__envade$rewrite.headers(s.headers,t),n=s.body;if(s.body)switch(e.destination){case"iframe":case"document":console.log("Rewriting HTML"),n=await self.__envade$rewrite.html(await s.text(),t);break;case"style":console.log("Rewriting CSS"),n=await self.__envade$rewrite.css(await s.text(),t);break;case"script":case"worker":case"sharedworker":console.log("Rewriting JS"),n=await self.__envade$rewrite.javascript(await s.text(),t);break;default:n=s.body}if(["document","iframe"].includes(e.destination)){let e=o.get("content-disposition")||"";if(!/^\s*(inline|attachment);\s*filename=/i.test(e)){let t=e.startsWith("attachment")?"attachment":"inline",r=s.finalURL?.split("/").pop()??"download";o.set("content-disposition",`${t}; filename=${JSON.stringify(r)}`)}}return new Response(n,{status:s.status,statusText:s.statusText,headers:o})}catch(e){return this.renderError(e,t)}}renderError(e,t){return console.error("[SW] Error",e,"for URL",t),new Response(`<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>Envade \u{2013} Error</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>body{font-family:sans-serif;background:#f9fafb;margin:0;padding:2em;color:#111}.container{max-width:600px;margin:auto;background:white;padding:2em;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.05)}h1{font-size:1.5rem;color:#e11d48}pre{background:#f3f4f6;padding:1em;border-radius:6px;overflow-x:auto}.url{color:#1e3a8a;margin-bottom:1em;font-size:.95em;word-break:break-all}</style></head><body><div class="container"><h1>Something went wrong</h1><div class="url">URL: ${t}</div><div><strong>${e.message||"Unknown error"}</strong></div><pre>${e.stack||"No stack trace available"}</pre></div></body></html>`,{status:500,headers:{"Content-Type":"text/html"}})}}})();
//# sourceMappingURL=en.worker.js.map